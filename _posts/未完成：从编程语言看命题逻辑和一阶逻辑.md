---
title: 草稿：（两篇内容）逻辑的发展和如何用python 表示 prolog 程序
date: 2020-11-11 21:22:46
tags:
---

## 逻辑的发展

## 逻辑三段论

逻辑三段论可能是形式最简单、历史最悠久的逻辑了。一般来说它有以下形式

```
大前提：所有 某类物体 都具有 某性质
小前提：某个个体 是 某类物体
结论：  某个个体具有某某性质
```

虽然它很简单，但是很有用。

比如我们在试图反驳某些观点的时候，我们可以这样：

反驳：板蓝根是中药，所以它没用

这句话的大前提是 所有中药都是没用的

小前提是 板蓝根是中药

结论 板蓝根没用

然而这是不对的，因为大前提是不对的，我没有检查所有中药对所有病症都没有用。

另外在这里也提一个很著名的悖论，白马非马，或者，黑乌鸦悖论。

黑马是马，我的是白马，所以白马不是马。

这里的大前提和小前提都是对的，但是他们不能推出结论，因为不符合三段论结构。（“逆命题和逆否命题”）

## 韦恩图

更进一步，如果我们想要更多分句，那么三段段论就不够了。我们用图画来表示逻辑。

显然图画很方便、形象，但是在分句过多的时候，好像就不是那么方便了。这时我们需要一套符号来表示图画。

## 命题逻辑

对于主流的计算机语言，一般都会支持命题逻辑。因此后面用一些计算机上的符号。

命题逻辑只能处理逻辑命题，其中命题必须能规约到 true 或者 false。

```Haskell
data Logic_Exp = 
	  Atom Prop
	| (Logic_Exp And Logic_Exp)
	| (Logic_Exp Or Logic_Exp)
	| (Not Logic_Exp)
data Prop = 
	  Tt
	| Ff
	| Var String
```

我们可以书写任意复合语法的命题逻辑表达式，但是表达式本身是无意义的。我们必须对表达式进行求值来计算表达式的意义。

下面用 haskell 代码来表示

```haskell
eval :: Logic_Exp -> Bool
eval (Atom Tt) = True
eval (Atom Ff) = False
eval (Atom (Var x)) = lookup(x,env)
eval (expr And expr') = eval
	
```

我知道这看起来很奇怪，我用 haskell 内置的逻辑语言重新定义了一个我自己的命题逻辑。然而计算机内部的逻辑本身就是用 命题逻辑 的形式表达的，我觉得我很难绕开这一部分。或许我下次可以使用

但是我在这里想表达的意思是 逻辑语言的形式 和 逻辑语言的语义 应该是分开的。在命题逻辑这里把它们混在一起还可以接受，然而，如果是一阶逻辑，那么把语义和形式放在一起讲就会比较混乱。



逻辑等价和重言式

这是一个十分有趣的话题，因为在做数学或者科学的时候，我们需要探讨一个研究是不是有意义。不过这篇文章不介绍这部分内容。

在正式介绍一阶谓词逻辑之前，我们可以先把命题逻辑写成谓词逻辑的样子。

如果今天下雨，我就不出门了。

rain(today) -> ~ goOut(me)

既然我们已经完成了谓词逻辑中“命题逻辑”的部分，我们就来看看用怎么用计算机处理“非命题逻辑”的部分。

很多问题我们都能使用命题逻辑解决，如果有涉及无穷的问题，我们也可以用逻辑三段论来表示。但是逻辑三段论的表现形式不够丰富，命题逻辑无法精确表述所有和有的，那么有没有一种语言能结合逻辑三段论和命题逻辑呢？

## 谓词逻辑

那么我们就需要谓词逻辑。

谓词逻辑里，我们有了两个量词，$\forall$ 和 $\exist$。

那么我们对一个谓词逻辑表达式求值，知道它的语义呢？

计算机如何处理谓词逻辑。

对于谓词逻辑，我们可以认为
$$
\forall x (P(x)) = \prod_{i=1}^n P_{x_i}
\\
\exist x(P(x)) = \sum_{i=1}^n P_{x_i}
$$
这里用了 布尔加法 和 布尔乘法 代替 一连串or 和 一连串and。

因此这样我们就可以把一阶逻辑规约到谓词逻辑了。我们用德摩根律把所有 $\forall$ 都换成 $\exist$ 然后看sum of product形式是不是一样的。问题是没有办法处理equal，只能把它作为一个命题来看待。

那么我们可以写出等价的 python 代码:

```python
# 先定义 situation 

## 定义 sort

Natural = {"apple", "banana", "carrot"}
Industrial = {"pizza", "coke", "sprite"}
Whole = Natural & Industrial

## 定义语义

def Food(x):
  return x in ("apple", "banana", "carrot", "pizza")

def Drink(x):
  return x in ("coke", "sprite")

def Dilicious(x):
  return x in Whole

# 所有Natural
all([P(x) for x in S])

# exist x in S, Q(x)
any([Q(x) for x in S])
```



python 中有一个非常好的性质，他的immutable type自动实现了 `__eq__` 方法，因此不需要重新实现一遍。

我们可以这样引入多元命题

```python
>>> a = ("a","b")
>>> b = ("a","b")
>>> a == b
True
>>> id(a)
140571992488688
>>> id(b)
```

```
a = set(("a","b"),("c","d"))
a.add(("a","b"))
# set(("a","b"),("c","d"))
```

我们可以这样用有限域中的万有分类定理

分离公理(又称为分离公理）：

$y \in \{ x \in A | P(x) \} \Leftrightarrow (y \in A \And P(y))$

这个公理使我们可以把逻辑命题写成集合的形式。



我们也可以用替代公理向集合论中引入函数：

$z \in \{y|P(x,y) \forall x\in A\} \Leftrightarrow \exist x  \in A P(x,z)$

如果我们让P为 $(y = x+1)$ 那么 $z\in \{x+1|\forall x \in A\}$



我们可以用笛卡尔积引入“多元集合”。



