---
title: 未完成：从编程语言看命题逻辑和一阶逻辑
date: 2020-11-11 21:22:46
tags:
---

逻辑的发展

在研究逻辑语言之前，我们需要阐明的是逻辑语言只能作用于“概念世界”，与“真实世界”无关。这是一个非常有趣的话题，但是这里只简单举个例子来说明这点。

句子1：世界上不存在黑色的天鹅。

句子1 可以判断真伪吗，一般来说是可以的，因为黑天鹅真的存在。

句子2: 世界上不存在蓝色的天鹅。

句子2 可以判断真伪吗，这里可能就会出现一些问题了。第一，我们很难去检查每一只天鹅，判断这只天鹅是不是蓝色的。第二，就算我们检查了地球上所有的天鹅，我们也不能保证宇宙中不存在蓝色的“天鹅”。第三，就算蓝色的天鹅存在，那蓝色的天鹅是天鹅吗？

我们可能会说我们有办法规避这些问题。比如把句子更改为，北京动物园里2020年11月26日不存在蓝色的天鹅。但是在我们更改句子的同时，我们实际上已经悄悄地把话语体系从“真实世界”转移到“概念世界”了。我们首先人为用概念划分了范围，又用概念表达了“蓝色”和“天鹅”。这个例子可能并不足以说明问题，那么我们还有另一个例子。

句子3: 哈利波特是一个魔法师。

我们一般相信哈利波特是一本杜撰的小说，哈利波特本人在“真实世界”也不存在。但是绝大多数人都会认为 句子3 是真的。这是因为我们没有在“真实世界”判断这句话是不是真的，我们本能地动用了“概念世界”中的概念来判断。

相似的，在我们提到钞票，国家，家庭，椅子的时候，我们实际上指的是那个概念，而那个概念 或有或无地 和“真实世界”相连结。当然一些基本一些的概念似乎和“真实世界”连结更紧密一些，而另一些连结得似乎不是那么紧密。比如我们就很难在指出什么是国家，什么是家庭。

因此，在我们讨论一个事情，尤其是用逻辑语言讨论某事情的时候，我们需要明确我们只是在“概念世界”中探讨。不然可能会出现一些看似“逻辑正确”的语句和现实不符的奇怪情况。当然，很多时候，“常识世界”充当了我们默认的“概念世界”。（“波普的三个世界”）这里也表明我们在说话的时候需要希望让对方理解，对方才能理解。或者说，我们说的时候指的“概念世界”听话人也必须理解同一个“概念世界”，我们说的话才能被听话人理解。

比如说我可以说 “乌鸦在精确的五小时自然对数分钟之后吃掉停车场”。这句话语法完全正确（至少我认为），但是你完全理解不了它背后所隐含的宏大思想。

逻辑三段论

逻辑三段论可能是形式最简单、历史最悠久的逻辑了。一般来说它有以下形式

```
大前提：所有 某类物体 都具有 某性质
小前提：某个个体 是 某类物体
结论：  某个个体具有某某性质
```

虽然它很简单，但是很有用。

比如我们在试图反驳某些观点的时候，我们可以这样：

反驳：板蓝根是中药，所以它没用

这句话的大前提是 所有中药都是没用的

小前提是 板蓝根是中药

结论 板蓝根没用

然而这是不对的，因为大前提是不对的，我没有检查所有中药对所有病症都没有用。

另外在这里也提一个很著名的悖论，白马非马，或者，黑乌鸦悖论。

黑马是马，我的是白马，所以白马不是马。

这里的大前提和小前提都是对的，但是他们不能推出结论，因为不符合三段论结构。（“逆命题和逆否命题”）

韦恩图

更进一步，如果我们想要更多分句，那么三段段论就不够了。我们用图画来表示逻辑。

显然图画很方便、形象，但是在分句过多的时候，好像就不是那么方便了。这时我们需要一套符号来表示图画。

并且引入符号也让我们可以处理有关自指的问题，但我觉得有自指的逻辑和无自指的逻辑是完全不同的两套系统。因此我们这里只介绍无自指的逻辑。

同时，在处理命题逻辑的时候，我们往往涉及一些复杂的概念，每个人认为的“概念世界”在这里可能差别较大，因此我们需要明确我们在什么哪个“概念世界”的话语体系内。同时我们应该区分句法和语义。

我们可以粗略的认为句法就是这个句子本身（一个符号串），而语义则是这个字符串在某一特定概念世界中是真的/假的。

对于主流的计算机语言，一般都会支持命题逻辑。因此后面用一些计算机上的符号。

命题逻辑只能处理逻辑命题，其中命题必须能规约到 true 或者 false。

```Haskell
data Logic_Exp = 
	  Atom Prop
	| (Logic_Exp And' Logic_Exp)
	| (Logic_Exp Or Logic_Exp)
	| (Not Logic_Exp)
data Prop = 
	  Tt
	| Ff
	| Var String
```

我们可以书写任意复合语法的命题逻辑表达式，但是表达式本身是无意义的。我们必须对表达式进行求值来计算表达式的意义。

下面用 haskell 代码来表示

```haskell
eval :: Logic_Exp -> Bool
eval (Atom Tt) = True
eval (Atom Ff) = False
eval (Atom (Var x)) = lookup(x,env)
eval (expr And expr') = eval
	
```

我知道这看起来很奇怪，我用 haskell 内置的逻辑语言重新定义了一个我自己的命题逻辑。然而计算机内部的逻辑本身就是用 命题逻辑 的形式表达的，我觉得我很难绕开这一部分。或许我下次可以使用

但是我在这里想表达的意思是 逻辑语言的形式 和 逻辑语言的语义 应该是分开的。在命题逻辑这里把它们混在一起还可以接受，然而，如果是一阶逻辑，那么把语义和形式放在一起讲就会比较混乱。



逻辑等价和重言式

这是一个十分有趣的话题，因为在做数学或者科学的时候，我们需要探讨一个研究是不是有意义。不过这篇文章不介绍这部分内容。

在正式介绍一阶谓词逻辑之前，我们可以先把命题逻辑写成谓词逻辑的样子。

如果今天下雨，我就不出门了。

rain(today) -> ~ goOut(me)

既然我们已经完成了谓词逻辑中“命题逻辑”的部分，我们就来看看用怎么用计算机处理“非命题逻辑”的部分。

很多问题我们都能使用命题逻辑解决，如果有涉及无穷的问题，我们也可以用逻辑三段论来表示。但是逻辑三段论的表现形式不够丰富，命题逻辑无法精确表述所有和有的，那么有没有一种语言能结合逻辑三段论和命题逻辑呢？

那么我们就需要谓词逻辑。

谓词逻辑里，我们有了两个量词，所有和有的。

那么我们对一个谓词逻辑表达式求值，知道它的语义呢？

计算机如何处理谓词逻辑。

对于谓词逻辑，我们可以认为
$$
\forall x (P(x)) = \prod_{i=1}^n P_{x_i}
\\
\exist x(P(x)) = \sum_{i=1}^n P_{x_i}
$$
这里用了 布尔加法 和 布尔乘法 代替 一连串or 和 一连串and。

因此这样我们就可以把一阶逻辑规约到谓词逻辑了。我们用德摩根律把所有 $\forall$ 都换成 $\exist$ 然后看sum of product形式是不是一样的。问题是没有办法处理equal，只能把它作为一个命题来看待。

python 中有一个非常好的性质，他的mutable type自动实现了 equals 方法，因此不需要重新实现一遍。

我们可以这样引入多元命题

```python
>>> a = ("a","b")
>>> b = ("a","b")
>>> a == b
True
>>> id(a)
140571992488688
>>> id(b)
```

```
a = set(("a","b"),("c","d"))
a.add(("a","b"))
# set(("a","b"),("c","d"))
```

我们可以这样用有限域中的万有分类定理

分离公理(又称为分离公理）：

$y \in \{ x \in A:P(x)\}\Leftrightarrow (y \in A \and P(y))$

这个公理使我们可以把逻辑命题写成集合的形式。



我们也可以用替代公理向集合论中引入函数：

$z \in \{y|P(x,y) \forall x\in A\} \Leftrightarrow \exist x  \in A P(x,z)$

如果我们让P为 $(y = x+1)$ 那么 $z\in \{x+1|\forall x \in A\}$



我们可以用笛卡尔积引入“多元集合”。



题外话：

逻辑和“真实世界”没有半毛钱关系，就算我说了

“这句话是假话”

世界也不会因为陷入无穷递归而突然宕机。

逻辑是对概念世界的描述。逻辑表达式可以随意给出，只要符合语法，一个表达式就是逻辑表达式。然而，要想知道逻辑表达式的“意思”，我们需要对逻辑表达式求值。

留一个小作业，怎么修改逻辑求值的规则，让下面表达式输出true

```python
def true_or_false():
    out = true_or_false() or True
    return out
```



forall x ( zombie[x] and (exist y (bite[x,y] -> sad[x]) and (forall y (bite [x,y] -> zombie[y])))



? forall X(p[X] -> exist Y r[X,Y])

? forall X forall Y(r[X,Y] or r[Y,X])

? exist X forall Y (r[X,Y] -> p[Y])

? exist X forall Y exist Z(r[X,Z] and ~eq[Z,Y])