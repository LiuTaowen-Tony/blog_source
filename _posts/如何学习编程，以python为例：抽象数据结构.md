---
title: 如何学习编程，以python为例：容器与复杂度转移
date: 2021-07-12 00:52:31
tags:
---

## 复杂度的转移

学过函数和基本的数据组合之后，我们介绍另一种编程中的重要思想：复杂度的转移。

在编程中，有些复杂度可以通过聪明的编程消除，但是剩下的一些复杂度是无论如何都消除不掉的。比如很多时候编程是在把某些算法重复施加在相似的对象上。

比如，对某个表格中的一列求和、在表格的一列中寻找符合某些特征的数据（数据 > 10）等。



这些复杂度是我们需要解决的问题本身带来的。但是好在我们可以转移这些复杂度到合适的地方，使得我们的程序 1. 更合理地划分层次 2. 这些复杂度转移的方法是大部分开发者所熟悉的，这可以让他们更好的理解我们写的代码



## 常用的数据结构

不同的语言中有不同的数据结构，但是他们的内核是相似的。我们可以大致分为线性数据结构，键值数据结构，非重数据结构。



## Python 中的数据结构

在 python 中有 4 种原生抽象数据结构，tuple list dict set。

其中 list 对应线性顺序数据结构

dict 对应 键值映射 结构

set 对应 非重数据结构

tuple 较为特殊，我希望将其视为基础数据的组合方式，而不是一种不可变容器，之前我们已经介绍过 tuple 了。



## 线性数据结构

线性数据结构 有两个用途： 顺序重要的时候 和 顺序不重要的时候

### 顺序不重要

> 这里是介绍 map filter reduce 的

编程中，我们经常遇到的一个问题是：对一组相似对象进行类似的操作。比如说对一组数求平方、给朋友圈的所有人点赞 或者 统计一本书里有多少个 e 等等。对于相似而没有层次关系的操作，我们使用线性数据结构。

用线性数据结构的原因是，线性数据结构有自递归特征，所以我们有一些通用的方法枚举每一个元素。而且，因为在计算机中，线性的数据结构储存开销不大，是一种“很简单”的数据结构。

对于顺序不重要的操作，我们可以使用映射操作来建模一些常用的行为。

包括 

1. 对一个集合的物体施加相似操作
   
   - 我希望把这个数据库的数据全部求平方。

2. 从集合提取符合条件的元素
   
   - 挑选重量大于 50 的西红柿。

3. 对集合中的元素进行总结
   
   - 对一个集合中的数求和



## 对一个集合的物体施加相似操作

比如我希望把这个数据库的数据全部求平方。

非映射操作：

```python
list_of_nums = [1, 3, 5, 7, 9]
i = 0
nList = len(list_of_nums)
list_of_squared_nums = list()
while i < nList:
  x = list_of_nums[i]
  squared = x * x
  list_of_squared_nums.append(squared)
  i += 1
```

首先我们要创造一个空的容器，准备存放平方过的数。然后我们按顺序取一个原有列表中的数，我们对这个数求平方，然后再加到新列表最后，最后我们还要对 index 加一。之后重复，直到原有列表中的所有元素都被访问到。

映射操作：

```python
list_of_nums = [1, 3, 5, 7, 9]
list_of_squared_nums = [(x * x) for x in list_of_nums]
```

对于所有 在 `list_of_nums` 中的元素，我们求平方，求过平方之后的列表的名字叫 `list_of_squared_nums`

如果使用了映射的思考方式，我们发现

1. 存取的顺序是不重要的
2. 我们不用具体描述数据是怎么被取出和放回的
3. index 这个中间变量消失了



## 从集合提取符合条件的元素

挑选重量大于 50 的西红柿。

```python
list_of_tomatos = [tomato(weight = 60), 
    tomato(weight = 40), tomato(weight = 20]
i = 0
nList = len(list_of_tomatos)
selected_tomatos = list()
while i < nList:
  x = list_of_tomato[i]
  if x.weight >= 50:
      selected_tomatos.append(x)
  i += 1
```

使用映射操作

```python
list_of_tomatos = [tomato(weight = 60), 
    tomato(weight = 40), tomato(weight = 20]

selected_tomatos = [x for x in list_of_tomatos if x.weight >= 50]
```

如果使用了映射的思考方式，我们发现

1. 存取的顺序是不重要的
2. 我们不用具体描述数据是怎么被取出和放回的
3. index 这个中间变量消失了



统计一本书中有多少个e的例子

非reduce操作：

```python
characters_of_a_book = [...]
nChar = len(characters_of_a_book)
i = 0
num_of_e = 0
while i < nChar:
    if characters_of_a_book[i] == "e":
        num_of_e += 1
    i += 1
```

reduce操作

重要的不是语法，而是你写代码的时候脑子里想的是什么。看起来我写的映射和过滤比非映射操作短的多，然而这并不重要。我们可以脑子里想着映射写循环（在没有提供映射操作的语言中），也可以脑子里想着循环写映射（在考虑运算复杂度的时候）。

我想根据一群人的身高体重，判断他们的 BMI

```python
# person = (height, weight)

list_of_BMI = [find_BMI_by_height_weight(height, weight)
               for height, weight in list_of_height_weight]
```

这里用了模式匹配和映射，这里如果需要可以去学一下

java 和 cpp 是没有这样的语法糖的，但是在写循环或者其他什么东西的时候，脑子里也要有映射的模型来指导代码应该怎么写。

要根据需要选择使用 惰性的 generator 或者是 list comprehension

这里我们藏起来了我们怎么对每个元素进行操作的复杂度，看起来我们写循环式代码量也不是很大，但是这是完全不同的两种思考方式。

这种思维方式所关注的是没个元素是怎么映射的，而循环则是更关注底层细节。

映射是一种更通用的操作，因为我们会对 dict 和 set 执行同样的操作。

还有一种常用操作是 filter，就是过滤一些元素，比如我想选出 overweighted 的元素

那么我这么写：

```python
over_weighted = [item for item in list_of_BMI if item > 26.5]
```

### 

### 顺序重要

很多场景下，我们对列表开头和结尾的元素更感兴趣。比如，我们希望处理一些数据访问请求，那么一种自然的方式就是先到先得。我们希望处理一件事物，但是处理这件事物的时候，我们发现它依赖某个前提条件，那么我们需要先处理前提条件，然后处理这项事物，那么这就是后到先得。

emm 这部分是介绍 stack 和 queue 的，我懒得写了。

## 键值数据结构

键值数据结构和线性数据结构在外观上看起来是相似的。

键值数据结构的实现方式一般有树和哈希表。不过在这篇文章中我们并不关心底层实现。

之前的线性数据结构中，我们并不关心每个元素的个体是怎么样的。而在键值数据结构中，我们关心每个个体具体是怎么样的。

比如之前线性数据结构中，我们可以做的是统计有多少人BMI指数超过了26 。这里，有了键值数据结构，我们可以查询某个具体的的人的 BMI 指数。

### 线性数据结构进化成键值数据结构

在线性数据结构的下标就是键的时候，线性数据结构就是键值数据结构。

比如说我知道我们班有 50 人，而且每个人都有有一个学号（从 0 开始🐶），那么我当我用列表储存我们班同学的身高时：我可以令下标就是学号，这样一来，我需要取用每个人的身高时，我不需要线性查找，而是直接使用下标取用。这和键值数据结构是等效的。

事实上，这也是 哈希表 的设计思路。

python 的强大之处在于：所有问题都用同一种方式解决，这种方式就是 for 循环。

## 非重数据结构

请注意，如果你只是想操作一些和顺序无关的数据，那么请使用 list 而不是 set。因为 set 有更高的复杂度，而对于 list 尽管 list 保证了数据的顺序，然而 list 的复杂度依然是低于 set 的。而且保存顺序不影响无序性。

## 递归型（类树）数据结构

很多时候我们会写出类似树一样的数据结构，而且是不由自主的。比如

一个网页有很多 block 组成