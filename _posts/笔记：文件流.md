---
title: 笔记：文件流
date: 2020-12-22 00:18:21
tags:
---

#  文件流

这里列举了一些和“文件”有关的概念，之后我应该还会重新整理一下。

## 一切皆文件

什么是文件？这是个很好的问题。我们可以读取，或者可以写入的东西，我们称为文件。计算机中很多东西，我们都可以读取或者写入，我们都可以把它们假装当作一个文件。



我觉得“一切皆文件”是一个非常好的抽象。它表示了计算机本质上是对数据进行处理的工具。我们可以把计算机的任意一个部分看作一个小小的计算机，它可以接受数据，也可以输出数据。



比如：

键盘是文件，因为键盘可以向计算机输入数据。

屏幕是文件，因为计算机可以向屏幕输入数据，之后屏幕通过显示的方式输出这些数据。

 TCP 链接是文件，因为我们可以从一个 TCP 链接中获取数据，也可以向一个 TCP 链接发送文件。



这样做的好处是，我们可以把忽略硬件和软件上的不同，把他们抽象成一样的接口操作。



1. 这样我们就在硬件和软件之间有了统一的接口。我们可以随意组合输入和输出，比如我可以把 TCP 链接的输出发送到屏幕，也可以把键盘的输入输出到音响。
2. 这样打打降低了我们的学习成本，比如我们学会了怎么读写文本文件，我们可以把一个网络连接看作是一个文本文件。通过相同的读写操作，我们就可以向这个网络连接发送信息。
3. 提供一定层面上合理的抽象，比如我希望我的屏幕上显示一串文字，但是我不想操作每一个像素点是否发光。我只需要向屏幕按所需格式扔过去我想显示的文字，那么屏幕内部就会搞清楚哪个点发光，哪个点不发光。

事实上我几乎不能想象不使用这样一种抽象的情景。



对于刚接触的人，一切皆文件不是一个很容易理解的概念。因为现代计算机中有很多文件格式，而现代操作系统都很聪明，他们会自动帮我们找到对应的应用程序打开文件。所以刚接触的人并没有经历过把一个图片文件用文本方式打开的情景。对于键盘、鼠标、硬盘和网络连接这样看起来毫不相干的东西，是在是很难想到一个公共的模型来描述他们共有的特征。



## 基础命令

|                |                                            |
| -------------- | ------------------------------------------ |
| echo 字符串    | 直接把input当成文本输出到output            |
| cat 文件名     | 把输入视为文件名，输出这个文件里的内容     |
| 命令 > 文件名  | 将命令的结果输入某文件（覆盖），不包括错误 |
| 命令 >> 文件名 | 将命令的结果附加在某文件末尾，不包括错误   |
| 命令1 \| 命令2 | 将命令1的结果输入命令2                     |
| 命令 &> 文件名 | 将命令的结果输入某文件（覆盖），包括错误   |
| 命令 2> 文件名 | 只将命令的错误输入某文件（覆盖）           |

值得注意的是

```shell
echo 1.txt | cat
```

的输出是 1.txt ，因为这段代码相当于

```shell
mkfifo anonymiousPipe
echo 1.txt > anonymiousPipe
cat anonymiousPipe
```

echo 1.txt 是把 1.txt 这串字符输入到了 一个匿名的管道中，之后用 cat 读取这个匿名管道。得到 1.txt 这段字符



上面提到了 `mkfifo`，这个命令就是用来生成管道的。我们除了可以用 `|`作为匿名管道，我们也可以用有名管道。

管道同样是一个文件

```shell
mkfifo myPipe
```

我们可以创建一个管道文件

```shell
echo "hello" > myPipe
```

向管道文件输入 "hello"

```shell
cat myPipe
```

从管道中获取输入



## 文件作为进程间



## 缓冲区

因为相对于 IO 操作来说，cpu 的速度太快了。所以我们一般是把要写的文件先存在缓冲区，之后再真正执行 IO 操作。比如说我们要向屏幕输出依次输出 `12345` 那么我们就要进行 5 次 IO。这样会拖慢速度，那么我们可以把 `12345` 先存到缓冲区，之后当缓冲区满了或者强制输出的时候，我们再把缓冲区的内容一并输出。



## Python

我们可以在外部更改默认的输出位置。

```shell
$ python >> 1.txt
```

这样我们默认在交互式python中默认的输出位置是追加到 1.txt 这个文件。那么我们 print 的内容不会在屏幕中显示，反而会出现在 1.txt 这个文件中。

这里就是我们让 shell 告诉 python 它的默认输出位置在 1.txt 这个文件。



除此以外，我们也可以在 python 内部告诉程序应该从哪里获得输入输出。



Python 中 print 函数的高级用法

```
print (value,...,sep='',end='\n',file=sys.stdout,flush=False)
```

其中的 file 参数就是输出的位置，sys.stdout 是默认输出到屏幕。

那么我们可以打开一个文件，print 输出到这个文件。

```python
f = open("output.txt","a")
print("hello world",file = f)
f.close()
```

值得注意的是，只有在文件关闭或者缓冲区满了的时刻，文件的内容才会被修改。print 函数只是暂时把要修改的内容存到了缓冲区。

我们还可以暂时把 stdout 换成一个文件

```python
f = open("output.txt","a")
sys.stdout = f
print("hello world")
f.close()
```

可惜文件关闭之后我们就不能向屏幕输出信息了。



除此以外，我们也可以使用 stdin 来实现更底层的输入机制。

```python
sys.stdin.readline().str IP ('\n') 
# 这里str IP 去掉最后的'\n'
# 和 input 不同，'\n' 不会默认去掉最后的换行
# 另外 stdin 不能输出提示，所以我们需要另外输出提示
```



我认为 input 和 print 可以看作是 stdout 和 stdin 的包装。而 stdout 可以看作是一个只写文件， stdin 可以看作是一个只读文件。所以归根结底，我们都可以通过写入或者读取文件的方式使用以上这些函数。



## StringIO 与 BytesIO

Python 提供了 StringIO 和 BytesIO 用来在内存里模拟文件。

比如说我们希望对照片做一些处理，这个处理需要用到不容的库，但是因为某照片处理库只能接受文件名作为输入，那么我们就可以用 BytesIO 暂存一下照片的中间过程，等全部处理好之后在输出到硬盘上。



## 写后感

1. 感觉看了 `sys.stdout` 和 `sys.stdin` 之后，`print` 和 `input` 这两个函数没那么拧巴了，理解它们到底在干嘛了。
2. Unix 、C 语言 和 TCP / IP 协议栈是一个整体，它们在设计的时候就很有同一性。它们里面的概念都很类似，而且组合使用起来非常方便。比如 C 语言的内存分配模型和 类 Unix 系统的进程组合工作的非常好， TCP / IP 的接口和 一切皆文件的抽象 组合起来也没有不舒服的地方。 http 中的地址和 类 Unix 系统的地址也是相似的。之前总觉得 Windows 的地址居然用反斜杠作为分隔符，实在是不能理解，现在觉得可能只是和太多和网络有关的软硬件借鉴了 Unix 的实现，而网络作为目前最重要的计算机应用，才会显得 Windows 和其他系统或软件不协调。