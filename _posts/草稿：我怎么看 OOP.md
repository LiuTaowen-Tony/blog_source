---
title: 草稿：我怎么看 OOP
date: 2021-02-13 23:07:41
tags:
---

除了大家常说的那些好处和不足以外，我个人还觉得 OOP 提供了一种对指针的抽象和一种安全的 metaprogramming 的思维方式。

OOP 有三个特点，封装、继承和多态。

封装是一种抽象方式，所有语言都会提供抽象方式，我觉得封装并不是很神奇。

但是对于继承和多态，我认为他们是一种 metaprogramming。

## 继承

继承是给 “子类” 提供了一些 函数 的 “默认实现”。如果没有 “继承” 这样的 polymorphism，我们需要写一个 “宏函数”，因为我们无法提供这个函数的实际类型签名。

```c++
#define SUM(x) (((x).first) + ((x).second))
```

类似这样

但是使用 OOP 之后

```c++
int sum(parentClass x){
	return x.getFirst + x.getSecond
}
```

这样我们避免了许多宏调用带来的问题。

## 多态

多态则是自动维护了一个虚表，这个虚表是穿透到运行时的。虚表在运行时根据继承关系确定到底使用哪个函数。我觉得编译期是不可能确定虚函数的调用关系的，因此，如果不自动生成虚表，那么需要程序在数据类型上添加一个 tag，标明自己的到底需要调用哪个函数。（看起来有点像 js 的继承链哈哈，但也可以用 tag 自动确定）。

题外话，因为有了继承（不同数据类型的共有方法）和多态（同名函数可以有不同的行为），所以我们可以使用模版来规范另一些宏。在编译之前，和宏类似，把模版类名替换成真实类名，因为有继承和多态，我们可以用同名函数处理不同 “数据类型”。（或者把真实类名upcast，利用虚表调用函数，然后再在合适的地方downcast e.g. `ArrayList.get`）。

综上，继承和多态是 OOP 实现 metaprogramming 的方式。

## 指针

但是OOP在此之上，还提供了对指针的封装。

在 Java 中，如果我们想 “修改全局变量”，我们能做的只有利用一个 Object 封装这个变量，然后对这个变量进行修改。而不能传递一个全局变量的指针。Python 提供了更多的方式，比如利用 global 关键字。

在 Java 和 Python 中，Object 都是内存回收的单位。在 C++ 中，语言提供了析构函数，用于析构实例。

对于同一个栈内变量，我们可以通过变量名取得内存地址，对这个内存地址所储存的数据进行修改。对于非同一个栈内的变量，我们则需要指针完成这件事。



